							DAY 5
							
Topics Covered :-

			DML :- DATA 
				INSERT / UPDATE / DELETE
						Manipulate the data of the tables....
			
			DDL : - 
					CREATE
						DATATYPES
							CONSTRAINTS
			
			TRANSACTION :- 
			
				DTL :-
					COMMIT 
					ROLLBACK 
					
			SHOW VARIABLES LIKE '%AUTOCIMMIT%';
			
			DML : ARE NOT AUTOCOMMIT IN NATURE
			DDL : ARE AUTOCOMMIT IN NATURE
			
			DQL :- SELECT : FETCH THE RECORDS FROM THE DATA
			
			SELECT 
				* 
					FROM 
						TABLENAME ;
						
			SELECT 
				*  -- COLUMN NAMES SEPERATED COMMA
					FROM 
						TABLENAME 
							WHERE CONDITION;
							
							
		SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

			CONDITION :: OPERATOR
			
				RATIONAL OPERATORS :-
					>  < >=  <= != =
					
				LOGICAL OPERATOR
					AND OR
					
					AND : BOTH THE CONDITION MUST BE TRUE
					OR  : ANY ONE CONDITION BE TRUE
					
----------------------------------------------------------------------

AIRTHMETIC OPERATORS :- 

	() , * , + , - , /
	
	
		BASIC CALCULATIONS
		INDIVIDUAL FUNCTIONS....

			SELECT (COMMNETS/COMMAND)

				SELECT 20000/20.5;
				
				-- ORACLE : SELECT 200000/20.4545;
				-- TABLE DUAL, ONE ROW AND ONE COLUMN
				-- SELECT 20000/343434.34 FROM DUAL;
				
				
			FIND CURRENTDATE :- 
				
					SELECT NOW();
					
			
QUESTION :-
		IF I NEED TO FIND ALL EMPLOYEES WITH THE INCREMENT OF 10% ON THEIR CURRENT SALARY.

			SELECT SALARY FROM EMPLOYEES;
			
			SELECT SALARY + (SALARY * 10/100) FROM EMPLOYEES;
			
			SELECT SALARY * 1.10 FROM EMPLOYEES;
			
				WE ARE NOT CHANGING ANYTHING IN THE DATABASE...
					SELECT COMMAND IS NEVER
						EVER CHANGE ANYTHING IN THE DATABASE...
						
			fUNCTION : RESCTICT THE NUMBER OF ROWS TO PRINT ON THE UI

				LIMIT : ALLOWS LIMIT THE ROWS
				
				
				SELECT SALARY * 1.10 FROM EMPLOYEES LIMIT 2;
				
				SELECT SALARY,SALARY * 1.10 FROM EMPLOYEES LIMIT 2;
				
			SALARY * 1.10 : COLUMNS NERVER EXIST IN YOUR DATABASE
					PSUEDO COLUMNS....
					
		ALIAS TO THE COLUMNS  : 
				RENAME OR CALLING WITH THE ANOTHER NAMES
					
				
		SELECT SALARY,SALARY * 1.10 NEWSALARY FROM EMPLOYEES LIMIT 2;
		
		
** whenever 
		WE DO ANY COMPARISON OR CALCULATION WITH NULL
			IT ALWAYS RETURN NULL
			
			SELECT NULL + 8;
			
			NULL
			
			SELECT 5 * NULL;
			
			NULL
			
** 	FIND ALL THE EMPLOYEES WITH THEIR SALARY WITH COMMISSION
				
				SALARY + COMMISSION....
				
			
*** TREATMENT TO THE NULL :-
	THEY INRRODUCE A FUNCTION NAME IFNULL
	
		IFNULL(COMMISSION_PCT,0)
		
			IF COMMISSION_PCT IS NULL THEN
				RETURN 0
			ELSE
				RETURN COMMISSION_PCT
				
			END
			
=================================================================

** FIND ALL THE EMPLOYEES GETTING NO COMMISSION.....

		INTRODUCE : 
				'IS' OPERATOR
				USED TO COMPARE WITH NULL VALUES
				
				SELECT * FROM EMPLOYEES WHERE COMMISSION_PCT IS NULL;
				
				IS NOT NULL
				
				SELECT * FROM EMPLOYEES WHERE COMMISSION_PCT IS NOT NULL;
			
==================================================================

OPERATORS :- 
				
			IN , LIKE 
			
			IN : USED TO COMPARE THE MULTIPLE VALUES WITH THE COLUMN
			
			
	** FIND ALL EMPLOYEES BELONGS TO DEPARTMENT 20 AND 30
	
			SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;
			
			SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID = 30;
			
			
			SELECT * FROM EMPLOYEES WHERE DEPARMTNET_ID IN (20,30);
			
			SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID = 20 OR DEPARTMENT_ID = 30;
			
			SELECT * FROM EMPLOYEES WHERE FIRST_NAME IN ('RAHUL','NIKHIL','JITESH');
			
		LIKE  : OPERATOR 
			USED TO COMPARE WITH THE VALUES 
				WHICH I AM NOT EXACTLY SURE...
						PARTIAL IMFORMATION RALTED TO THE VALUE....
						
	     * NEED TO FIND ALL THE EMPLOYEES STARTING WITH A 
		 
			TWO WHILD CARDS :-
			
				%			:: N NUMBER OF CHARATERS
				
				
				_			:: SINGLE CHARATER
				
				
			
			SELECT * FROM EMPLOYEES WHERE FIRST_NAME LIKE 'A%';
			
			
		* NEED TO FIND ALL THE EMPLOYEES ENDING WITH A 	
		
			SELECT * FROM EMPLOYEES
					WHERE FIRST_NAME LIKE '%A'
					
					
		* FIND ALL THE EMPLOYEE HAVING EH IN THERE NAME

			
			SELECT * FROM EMPLOYEES
					WHERE FIRST_NAME LIKE '%EH%';
					
		* FIND ALL THE EMPLOYEES WHOSE THIRD CHARATER IS A%
		
			SELECT * FROM EMPLOYEES	
					WHERE FIRST_NAME LIKE '__A%';
					
==========================================================================

PSEUDO :-
			COLUMNS NOT EXIST IN THE DATABASE....
			
			SELECT SALARY,SALARY * 1.10 NEWSALARY FROM EMPLOYEES;

				
		ALIAS :- 
				NEW NAME TO THE COLUMN ONLY FOR THE OUTPUT....
				
		ALIAS IS ON SIGLE WORD THEN WE CAN USE AS IS

		ALIAD IS MORE THEN ONE WORD THEN USE A
			KEY 'AS' AND PUT YOUR ALIAS INSIDE THE SIGLE QUOTE
			
			SELECT FIRST_NAME AS 'FIRST NAME' FROM EMPLOYEES;
					
=====================================================================

SELECT 
		*
			FROM 
				TABLE
					WHERE CONDITIONS ;
					
FETCH THE DATA FROM MY DATABASE
	USER WANT THAT DATA TO PRESENT IN SOME SORTED FORMAT...
			SORT MY DATA ON DEPARTMENT_ID
					ASCENDING ORDER
					DESENDING ORDER
					
======= CLAUSE : ORDER BY 
			USER TO SORT THE DATA BASED ON THE COLUMNS PROVIDED 
			LAST CLAUSE OF THE SELECT STATEMENT....
			
			
	** FIND ALL THE EMPLOYEES NAME AND SALARY AND INCREMENTAL SALARY WITH 10% AND SORT THE DATA BASED ON DEPARTMENT ID
	
	SELECT 
		FIRST_NAME NAME,DEPARTMENT_ID, SALARY OLDSALARY,SALARY*1.10 AS 'INCREMENTAL SALARY'			
				FROM
					EMPLOYEES
						ORDER BY DEPARTMENT_ID;
					
			DEFAULT IS ASC .....

			
					
	SELECT 
		FIRST_NAME NAME,DEPARTMENT_ID, SALARY OLDSALARY,SALARY*1.10 AS 'INCREMENTAL SALARY'			
				FROM
					EMPLOYEES
						ORDER BY DEPARTMENT_ID DESC;				
					
					
------ MAY BE A PROVISION 
					WHERE I WANT TO APPLY SORTING ON TWO COLUMNS...
					
			ORDER BY (COLUMNNAME SEPERATED WITH COMMA)..
			
				
		101 RAHUL 2000 MANAGER 30
		102 NIKHIL 3000 DEVELOPER 20
		103 JITES 5000 MARKETING 30
		104 PRIYANKA 6000 QUALITY 20
		105 SUNITA 7800 MARKETING 30
		106 RAMESH 3056 DEVELOPER 20
					
	** SORTED FORMAT ON DEPT_ID AND JOB_DESC

		ORDER BY DEPT_ID,JOB_DESC
		
		BASED ON THE FISRT COLUMN DEPT_ID IT SORTED THE DATA IN ASC
		
		EXECUTION :- 
		102 NIKHIL 3000 DEVELOPER 20
		104 PRIYANKA 6000 QUALITY 20	
		106 RAMESH 3056 DEVELOPER 20
		101 RAHUL 2000 MANAGER 30
		103 JITES 5000 MARKETING 30
		105 SUNITA 7800 MARKETING 30	
		
		CREATE A GROUP BASED ON THE FIRST COLUMN - DEPT_ID
		
		GROUP 1
		102 NIKHIL 3000 DEVELOPER 20
		104 PRIYANKA 6000 QUALITY 20	
		106 RAMESH 3056 DEVELOPER 20
		
		GROUP 2
		101 RAHUL 2000 MANAGER 30
		103 JITES 5000 MARKETING 30
		105 SUNITA 7800 MARKETING 30
		
		------------------------------------
		102 NIKHIL 3000 DEVELOPER 20
		106 RAMESH 3056 DEVELOPER 20
		104 PRIYANKA 6000 QUALITY 20
		101 RAHUL 2000 MANAGER 30
		103 JITES 5000 MARKETING 30
		105 SUNITA 7800 MARKETING 30
		
========================================================================


SELECT (MANDATORY)
	* 
		FROM  (MANDATORY)
			TABLES
				WHERE (OPTIONAL)
					CONDITION
						ORDER BY (OPTIONAL)
							COLUMN NAMES........................

=======================================================================


RESTRICTION :-
				COLUMNS SEPERATED WITH COMMA BETWEEN SELECT AND FROM
				WHERE CONDITION
				LIMIT 
				
** SUPPRESS THE SUPLICATE RECORDS.....

	FIND ALL THE DEPARTMENTS WHERE EMPLOYEES WORKS ..
	
		DISTINCT 
		
			SELECT DISTINCT DEPARTMENT_ID,JOB_ID FROM EMPLOYEES;
			
			
========================================================================

	ORDER BY DEPT_ID AND JOB_ID

		101 RAHUL 2000 MANAGER 30
		102 NIKHIL 3000 DEVELOPER 20
		103 JITES 5000 MARKETING 30
		104 PRIYANKA 6000 QUALITY 20
		105 SUNITA 7800 MARKETING 30
		106 RAMESH 3056 DEVELOPER 20

		A
		102 NIKHIL 3000 DEVELOPER 20
		104 PRIYANKA 6000 QUALITY 20
		106 RAMESH 3056 DEVELOPER 20
		
		B
		101 RAHUL 2000 MANAGER 30
		103 JITES 5000 MARKETING 30
		105 SUNITA 7800 MARKETING 30
		

		
		102 NIKHIL 3000 DEVELOPER 20
		106 RAMESH 3056 DEVELOPER 20
		104 PRIYANKA 6000 QUALITY 20
		101 RAHUL 2000 MANAGER 30
		103 JITES 5000 MARKETING 30
		105 SUNITA 7800 MARKETING 30


		ORDER BY DEPARTMENT_ID,JOB_ID DESC ,SALARY
		
		
		
		
		ORDER BY DEPARTMENT_ID DESC, JOB_ID DESC,SALARY ASC

==========================================================================

SALARY * 10.3

FIRST_NAME + LAST_NAME

SELECT 'RAHUL' AS NAME,SALARY FROM EMPLOYEES;

===================================================================

DISTICNT :-
	USED TO SUPRESS THE DUPLICATE VALUES..
	
==========================================================================

DDL :- 

	CREATE / ALTER / DROP

	THESE COMMANDS ARE USED TO DO ANY MODIFICATION IN YOUR TABLES STRUCTURE...
		
			CREATE  : USED TO CREATE NEW TABLES IN THE DATABASE....
			
			CREATE DATABASE DATABASENAME;
			
ALTER :- 
		USED TO MODIFY THE EXISTING STRUCTURE OF THE TABLE...
		
		
 *  
	* NEW COLUMNS IN THE TABLE.
	* REMOVE THE EXISTING COLUMN
	* MODIFY THE LENGTH OF THE EXISTING COLUMNS
	* DROP SOME CONSTRAINTS
	* ADD CONSTRAINTS
	* RENAME THE NAME OF THE COLUMNS
	* RENAME THE TABLE NAME...
	
** ADD NEW COLUMN IN THE TABLE :- 
	
		SYNTAX : 
			
		ALTER TABLE TABLENAME ADD COLUMNNAME DATATYPE CONSTRAINT;
		
		ALTER TABLE EMPLOYEES ADD EMP_ALTERNATE_MOBILNO BIGINT;
		
		-------------------------------------
		
		MYSQL PROVIDED 2 MORE FETURES FOR ADDING COLUMN AT PERTICULAR POSITION....
		
		CREATE TABLE EMPLOYEE
		(
			ID INT PRIMARY KEY,
			NAME VARCHAR(30),
			MOBILNO BIGINT,
			SALARY INT,
			DEPT_ID INT
		);
		ALTER TABLE EMPLOYEES ADD EMP_ALTERNATE_MOBILNO BIGINT;
		
		
			ID INT PRIMARY KEY,
			NAME VARCHAR(30),
			MOBILNO BIGINT,
			SALARY INT,
			DEPT_ID INT,
			EMP_ALTERNATE_MOBILNO BIGINT
		
		FIRST , AFTER.....
		
*  NEED TO HAVE A COLUMN AT FIRST POSITION..
	
		ALTER TABLE EMPLOYEES ADD EMP_ALTERNATE_MOBILNO BIGINT FIRST;
		STRUCTURE :-
			EMP_ALTERNATE_MOBILNO BIGINT,
			ID INT PRIMARY KEY,
			NAME VARCHAR(30),
			MOBILNO BIGINT,
			SALARY INT,
			DEPT_ID INT
			
* NEED TO HAVE A COLUMN AFTER MOBILENO

		ALTER TABLE EMPLOYEES 
			ADD EMP_ALTERNATE_MOBILNO BIGINT AFTER MOBILNO;
			
		STRUCTURE :-
			ID INT PRIMARY KEY,
			NAME VARCHAR(30),
			MOBILNO BIGINT,
			EMP_ALTERNATE_MOBILNO BIGINT,
			SALARY INT,
			DEPT_ID INT


=============================================================

MODIFY THE EXISTING COLUMN DEFINATION :- 
	MODIFY 
	
	FIRST_NAME VARCHAR(10)...
	
	ALTER TABLE TABLENAME MODIFY EXISTINGCOLUMN DATATYPE;

	ALTER TABLE EMPLOYEES MODIFY FIRST_NAME VARCHAR(50);
	
	----------------------------------------------------
	
	CONSIDER A SCENARIO :- 
			FIRST_NAME ALLOWS TO HAVE A NULL VALUE
			
			RAHUL
			NIKHIL
			NULL
			JITES...
			
	ALTER TABLE EMPLOYEES MODIFY FIRST_NAME VARCHAR(30) NOT NULL;

	
=========================================================================

DEFAULT :-

	ALTER TABLE EMPALTER MODIFY SALARY INT NOT NULL DEFAULT 7000;

========================================================================


PRIMARY KEY :- 

ALTER TABLE TABLENAME MODIFY COLUMNNAME DATATYPE PRIMARY KEY;

========================================================================

** CHANGE YOUR COLUMN NAME NAMES :- 

	CHANGE : RENAME THE COLUMN NAME OF THE EXISITNG COLUMNS...
	
	SYNTAX :- 
		ALTER TABLE TABLENAME CHANGE OLDNAME NEWNAME DATATYPE;
		
** 

DROP EXISTIN DEFAULT CONSTRAINTS

	ALTER TABLE TABLENAME ALTER COLUMNNAME DROP DEFAULT...
	
	ALTER TABLE EMPALTER ALTER I DROP DEFAULT;
	
	
	IF YOU NEED TO CHANGE THE DEFAULT VALUE :-
	
	ALTER TABLE EMPALTER ALTER I SET DEFAULT 1000;
	
*******************

RENAME YOU TABLE NAME :- 

	RENAME....
	
SYNTAX :- 
		ALTER TABLE TABLENAME RENAME TO NEWNAME;
		
		ALTER TABLE EMPALTER RENAME TO EMPASSIGNMENT;
		
		
	========================================================

ADD CONSTRAINTS IN YOUR TABLE :- 

	*	ADD A PRIMARY KEY :-
			
			SYNTAX :- 
			
			ALTER TABLE TABLENAME ADD PRIMARY KEY(COLUMNNAME);
			
			ALTER TABLE EMPALTER ADD PRIMARY KEY(ID);
			
			
			ALTER TABLE EMPALTER ADD PRIMARY KEY(ID,NAME);
			
		DROP A PRIMARY KEY :-	
		
			ALTER TABLE TABLENAME DROP PRIMARY KEY;
			
		
	* FOREIGN KEY 
		
		* ADD FOREIGN KEY

		ALTER TABLE TABLENAME ADD FOREIGN KEY(COLUMNNAME)
				REFERENCES PARENTTABLE(PARENTCOLUMNAME);
				
			
		ALTER TABLE TABLENAME 
			ADD CONSTRAINT CONSTRAINT_NAME 
					FOREIGN KEY(COLUMNNAME)
							REFERENCES PARENTTABLE(PARENTCOLUMNAME);
							
		* DROP FOREIGN KEY OR ANY CONTAINTS WITH THE NAME

			ALTER TABLE TABLENAME 
				DROP CONSTRAINT CONSTRAINTNAME;
				
			ALTER TABLE EMPLOYEES
				DROP CONSTRAINT EMP_FK;
				
			ALTER TABLE EMPLOYEES
				DROP FOREIGN KEY EMP_FK;
			
		**************************************************

UNIQUE : 
	
		* ADD UNIQUE 
		
		ALTER TABLE TABLENAME ADD UNIQUE(COLUMN NAME);
		
		ALTER TABLE EMPLOYEES ADD UNIQUE(MOBILENO);
		
		
			ALL THESE KEYS WITH ALTER :-
				USED TO MANIPUATE THE EXISTING STRUCTURE OF YOUR TABLES...
			
			* ADD : ADDING NEW COLUMNS
			* MODIFY : USED TO MODIFY THE EXISTING DEFINATION OF COLUMN
			* CHANGE : RENAME THE COLUMNS NAME
			* RENAME : USED TO RENAME THE TABLENAME
			* DROP : USED TO DROP THE CONSTARINTS, DROP THE COLUMNS...
			
			
			ALTER TABLE EMPLOYEE DROP COLUMN FIRST_NAME;
			
========================================================================

DROP :- 

			DROP IS USED TO DROP THE EXISTING STRUCTURE WITH THE DATA..
			
			DROP TABLE TABLENAME;
			
			DROP DATABASE DATBASENAME;
			

	ALL DDL ARE AUTOCOMMIT IN NATURE....
			THERE IS NO ROLLBACK TO THIS.....
			
			
========================================================================			
	DDL / DML / DQL / DTL 

DCL :- 
		GRANT / REVOKE 
		
	
	** CREATE ONE USER : -
		
			CREATE USER USERNAME IDENTIFIED BY 'PASSWORD';
			
		CREATE USER NIKHIL IDENTIFIED BY NIKHIL;	
			
			
	** FOR GRANTING SOME PERMISSION :- 
	
			GRANT : 
			
			SYNTAX :- 
			
				GRANT () ON SCEMANAME/TABLE TO USER;
				
				GRANT  : KEY
				
				()    : ALL (ALL PERMISSION) , SELECT ,
						SELECT INSERT
				
				ON   : KEY 
				
				SCEMANAME/TABLE : 
					DATABASENAME.* (ALL TABLES UNDER DATABASE)
					
					DATABASE.TABLENAME..
					
					*.*   ALL DATABASE TO ALL TABLES...
					
				TO  KEY 
				
				USER : NAME OF THE USER
				
			
===============================================================

REVOKE : REVOKE CERTAINTS PERMISISSION :- 

				REVOKE (PERMISSION) ON DB.TABLE FROM USER;
				
		
		ALL , GRANT ...
		
=======================================================================

THIS IS HOW :-
				YOUR ALL CATEGORIES ARE DIVIDED :- 
				
		DQL : 
			SELECT 
		DDL : 
			CREATE / ALTER / DROP
		DML :
			INSERT / UPDATE / DELETE
		DCL :
			GRANT / REVOKE 
		DTL : 
			COMMIT / ROLLBACK
			
		TRUNCATE : ANOTHER COMMAND 
			(DDL) - NEVER EVER IMPACT THE DATABASE STRUCTURE.....
			
			
=======================THANK YOU ==============================			
		









	
			
			
			
				