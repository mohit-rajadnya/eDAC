							DAY 10
							
TOPICS COVERED :- 

	IN THE LAST SESSION :-
	
			PLSQL :- 
			
				BLOCKS :-
				
					BEGIN
					DECLARE
					END
				
				INSIDE MYSQL := 
				
					PROCEDURE....
					
					
				CREATE PROCEDURE PROCEDURENAME( IN/OUT/INOUT)
				BEGIN
				
				STATEMENTS....
				
				END;
				
				STATEMENTS WHICH WE USED INSIDE MY PROGRAM REQUIRED ; AS A TERMINATOR
				
				SO CREATING PROCEDURES/FUNCTIONS/TRIGGERS..
					CONTAINING STATEMENTS..
					
				FIRST WE NEED TO CHANGE THE DELIMITER OF YOUR CONSOL
				
				CHANGING :- 
				
						DELIMITER //
					
			IF WE NEED TO MOVE VALUES RETURN FROM THE SELECT STATEMENT :- 
			
			SYTAX OF SELECT GOT LITTLE CHANGE
			
			SELECT COLUMN OR FUNCTIONS INTO VARIABLE
				FROM TABLE;
			
			SELECT MAX(SALARY),MIN(SALARY) INTO X,Y FROM EMPLOYEES;
	
			X = MAX(SALARY);
			Y = MIN(SALARY)
	============================================================				
	NEXT :-

		CONDITIONAL OPERATORS TO HANDLE THE CONDITIONS
		
	1) 	IF ELSE END.....
	
		SYNTAX :- 
		
			IF EXPRESSION THEN
				STATEMENTS;
			ELSE 
				STATEMENTS;
			END IF;
		
			EXECUTE IF STATEMENT WHEN EXPRESSION = TRUE
			ELSE
			EXECUTE THE ELSE STATEMENTS....
			
	2) MULTIPLE COMPARISONS :- 

		SYNTAX :- 
		
			IF EXPRESSION THEN 
				STATEMENTS;
			ELSEIF EXPRESSION THEN
				STATEMENTS;
			ELSE
				STATEMENTS;
			END IF;
			
EXAMPLE P8 :-

		NEED TO PRINT BELOW EXPECTED STATEMENTS :- 
		1) ENTER THE EMPLOYEE ID TO THE PROGRAM
		2) BASED ON THE SALARY CONDITIONS NEED TO PRINT HIS LEVEL
		
		SALARY > 15000 (LEVEL : HIGH)
		SALARY < 15000 AND SALARY > 10000 (LEVEL : MEDIUM)
		SALARY < 10000 (LEVEL : LOW)
		
		
		DELIMITER //
		
		DROP PROCEDURE IF EXISTS P8 //

		CREATE PROCEDURE P8(X INT, OUT LEVEL VARCHAR(50))
		BEGIN
		
		DECLARE SAL INT;
		
		SELECT SALARY INTO SAL FROM EMPLOYEES WHERE EMPLOYEE_ID = X;
		
		-- SELECT SALARY FROM EMPLOYEES WHERE EMPLOYEE_ID = 102;
		-- 4900
		-- 4900 INTO SAL
		-- SAL = 4900;
		
		IF SAL > 15000 THEN 
			SET LEVEL = 'HIGH';
		ELSEIF SAL > 10000 AND SAL < 15000 THEN
			SET LEVEL = 'MEDIUM';
		ELSE 
			SET LEVEL = 'LOW';
		END IF;
		
		END //
		
		DELIMITER ;
				
		CALLING TO THE PROCEDURE :- 
		
	===========   CALL P8(102,454);  =========
	
				CREATE A VARIABLE : LEVEL
				PASS THE ADDRESS OF T TO THE PROGRAM
				
						@T
				
=====================================================================

CONDITIONAL := 
		CASE : ALREADY GONE THROUGH  IN THE SELECT 
		
		
			CASE 
			WHEN CONDITION THEN STATEMENT;
			WHEN CONDITION THEN STATEMENT;
			.
			.
			.
			ELSE STATEMENT;
			END CASE;
			
			CASE VARIABLE
			WHEN VALUE THEN STATEMENT;
			WHEN VALUE THEN STATEMENT;
			.
			.
			.
			ELSE STATEMENT;
			END CASE;
			
EXAMPLE := 
	P9 : NEED TO SPELL OUT THE NUMBER ENTER TO THE PROGRAM 
		FROM 1 TO 10
		
		DELIMITER //
		
		DROP PROCEDURE IF EXISTS P10 //
		
		CREATE PROCEDURE P10(X INT)
		BEGIN
		
		CASE X
			WHEN 1 THEN SELECT 'ONE';
			WHEN 2 THEN SELECT 'TWO';
			WHEN 3 THEN SELECT 'THREE';
			WHEN 4 THEN SELECT 'FOUR';
			WHEN 5 THEN SELECT 'FIVE';
			WHEN 6 THEN SELECT 'SIX';
			WHEN 7 THEN SELECT 'SEVEN';
			WHEN 8 THEN SELECT 'EIGHT';
			WHEN 9 THEN SELECT 'NINE';
			WHEN 10 THEN SELECT 'TEN';
			ELSE SELECT 'OUT OF BOUND VALUE';
		END CASE;
		
		END //
		
		DELIMITER ;
		
====================================================================

LOOPS  :- 
		CONTINUE EXECUTING CERTAIN STATEMENT UNTILL THE CONDITION
			BECOME FALSE
	
			WHILE LOOP :- 
			
			SYNTAX :- 

				WHILE EXPRESSION/CONDITION DO 
					STATEMENTS...
				END WHILE;
				---
		
EXAMPLE  :- FIBONACCI SEREIES := 

				0,1,1,2,3,5,8,13,......
				
				FNUM = 0
				SNUM = 1
				
				THEN
				
				TNUM = FNUM + SNUM;
				FNUM = SNUM;
				SNUM = TNUM;
				
			
		DELIMITER //
		
		DROP PROCEDURE IF EXISTS P11 //
		
		CREATE PROCEDURE P11(X INT)
		BEGIN
		
		DECLARE FNUM INT DEFAULT 0;
		DECLARE SNUM INT DEFAULT 1;
		DECLARE TNUM INT;
		
		DECLARE FSERIES VARCHAR(500);
		
		SET FSERIES = CONCAT(FNUM,',',SNUM); -- FSERIES = 0,1
				
		WHILE X > 2 DO 
		
			SET TNUM = FNUM + SNUM;
			SET FNUM = SNUM;
			SET SNUM = TNUM;
			
			SET FSERIES = CONCAT(FSERIES,',',TNUM); -- FSERIES = 0,1,1
			
			SET X = X-1;
			
		END WHILE;

		SELECT FSERIES;
		
		END //
		
		DELIMITER ;
		
				
2)
	LOOP 
	
		LEAVE LOOP

			LOOP_LEVEL : LOOP
			
				LEAVE LOOP_LEVEL   -- BREAK STATEMENT ....
				
				
			
===================================================================

CURSORS :- 

		IS A POINTER 
			WHICH CONTAINS A SET OF LINE RETURN FROM THE 
				SELECT STATEMENT....
		AND POINTS TO THE FIRST ROW OF THE OUTPUT...

	CURSOR  ---> 101 RAHUL 5000 
			     102 NIKHIL 6000
			     103 KRISHAN 7000
			
		CURSOR DEFINATIONS WILL CONTAINS SELECT STATEMENT...
		
		CURSOR WILL BE CREATED IN THE PROGRAM WITH THE 
			HELP OF SELECT STATEMENT.....
			
	SYNTAX :- 

		DECLARE CURSOR CURSORNAME  FOR SELCT STATEMENT;
		
		DECLARE CURSOR CRUSORNAME FOR 
				SELECT FIRST_NAME , EMPLOYEE_ID, SALARY FROM EMPLOYEES;
				
		NEED TO DECLARE A VARIABLE WITH THE TYPE OF TABLE COLUMNS SELECTED...
			WE CAN USE CURSOR.....
			
		EXECUTE YOUR CURSORS :- 
				THREE STEPS :
				
			
		1) OPEN CURSOR
		
			OPEN CRUSORNAME;
			
			EXECUTE THE STATEMENT USED FOR THE CURSOR...
			CREATE A TABLE INSIDE THE TEMP MEMORY
			CURSOR START POINTING TOWARDS THE FIRST ROW....
			
	CURSOR  ---> 101 RAHUL 5000 
			     102 NIKHIL 6000
			     103 KRISHAN 7000
			
			
		2) FETCH THE VALUES FROM THE CURSOR
			
			FETCH THE FIRST RECORD TO WHOM ITS POINTING
			
				101 RAHUL 5000
				
			FETCH CRUSORNAME INTO X,Y,Z;
			
				X = 101
				Y = RAHUL
				Z = 5000
				
	CURSOR  ---> 102 NIKHIL 6000
			     103 KRISHAN 7000
				 
	CURSOR ---> NO RECORDS......
				THROWS EXCEPTION : "NOT FOUND"
			
		3) CLOSE THE CURSOR
		
				CLOSE THE POINER CURSOR....
			
			
-----------------------------------------------------------------------

P12 :- 

	FIND ALL THE EMPLOYEES SALARY AND INCREMENT SALARY BY 15%
		NEED TO PRINT OLD SALARY AND NEW SALARY 


		DELIMITER //
		
		DROP PROCEDURE IF EXISTS P11 //
		
		CREATE PROCEDURE P11()
		BEGIN 
		DECLARE CNUM INT;
		DECLARE EMPID INT;
		DECLARE EMPSAL INT;
		DECLARE EMP_CURSOR CURSOR 
				FOR SELECT EMPLOYEE_ID,SALARY FROM EMPLOYEES;


		SELECT COUNT(*) INTO CNUM FROM EMPLOYEES;
		
		OPEN EMP_CURSOR;   -- FIRST STEP 
		
		L_LEVEL : LOOP   -- LOOP STARTS HERE
		
			IF CNUM <= 0 THEN
				LEAVE L_LEVEL;  -- BREAK IN YOUR PROGRAM
			END IF;
		
		FETCH EMP_CURSOR INTO EMPID,EMPSAL;
			
		SELECT CONCAT('OLD SALARY OF EMPLOYEE : ', EMPID, 'AFTER INCREMENT SALARY BECOME ' , EMPSAL * 1.15);
		
		SET CNUM = CNUM - 1;
		
		END LOOP L_LEVEL;
		
		CLOSE EMP_CURSOR;
		
		END //
		
		DELIMITER ;
		
=====================================================================

** 	FETCH CURSOR INTO VARIABLE...

		WHEN CURSOR REACHED THE LAST LINE...
				FETCH : 
						RETUNS A EXCEPTION CALLED 'NOT FOUND'
						
		
	WE CAN HANDLE THIS EXCEPTION IN THE PROGRAM 
		WITH THE HELP OF EXCEPTION / ERROR 
			HANDLING IN MYSQL :- 
			
		
	ERROR HANDLING IN MYSQL 
			INSIDE THE PROCEDURE :- 
			
	DECLARE HANDLERS IN THE PROGRAM :- 
	
	SYNTAX :- 
	
	
	DECLARE ACTION HANDLER FOR CONDITION STATEMENTS;
	
		DECLARE : DECALRING THE VARIABLE/HANDLERS..
		
		
		ACTION : EXIT , CONTINUE
			
			EXIT : WHENEVER YOU GET AN EXCEPTION IN THE PROGRAM.
					HANDLE IT AND MOVE OUT FROM YOUR PROGRAM 
							PROCEDURE...
						
			CONTINUE : WHENEVER YOU GET AN EXCEPTION IN THE PROGRAM 
						HANDLE IT AND CONTINUE WITH THE PROGRAM....
						
		CONDITION : 
					NOT FOUND 
					SQLEXCEPTION
					SQLWARNING
					EXCEPTION NUMBER.. 
						
					
PROGRAM WITH EXIT :- 
				
				
		DELIMITER //
		
		DROP PROCEDURE IF EXISTS P12 //
		
		CREATE PROCEDURE P12()
		BEGIN 
		DECLARE V_FINISH INT DEFAULT 0;
		DECLARE EMPID INT;
		DECLARE EMPSAL INT;
		DECLARE EMP_CURSOR CURSOR 
				FOR SELECT EMPLOYEE_ID,SALARY FROM EMPLOYEES
						WHERE DEPARTMENT_ID = 20;
		DECLARE EXIT HANDLER FOR NOT FOUND SET V_FINISH = 1;


		OPEN EMP_CURSOR;   -- FIRST STEP 
		
		L_LEVEL : LOOP   -- LOOP STARTS HERE
		
			IF V_FINISH = 1 THEN
			LEAVE L_LEVEL; 
			END IF;
		
		FETCH EMP_CURSOR INTO EMPID,EMPSAL;
			
		SELECT CONCAT('OLD SALARY OF EMPLOYEE : ', EMPID, 'AFTER INCREMENT SALARY BECOME ' , EMPSAL * 1.15);
		
		END LOOP L_LEVEL;
		
		CLOSE EMP_CURSOR;
		
		SELECT COUNT(*) FROM EMPLOYEES;
		
		END //
		
		DELIMITER ;



PROGRAM WITH CONTINUE :- 

		DELIMITER //
		
		DROP PROCEDURE IF EXISTS P13 //
		
		CREATE PROCEDURE P13()
		BEGIN 
		DECLARE V_FINISH INT DEFAULT 0;
		DECLARE EMPID INT;
		DECLARE EMPSAL INT;
		DECLARE EMP_CURSOR CURSOR 
				FOR SELECT EMPLOYEE_ID,SALARY FROM EMPLOYEES
						WHERE DEPARTMENT_ID = 20;
		DECLARE CONTINUE HANDLER FOR NOT FOUND SET V_FINISH = 1;


		OPEN EMP_CURSOR;   -- FIRST STEP 
		
		L_LEVEL : LOOP   -- LOOP STARTS HERE
			
	EMP_CURSOR --> 		101 RAHUL 3000
						102 NIKHIL 4000	
						
		1ST TIME LOOP : 
				101 RAHUL 3000
				
		
		EMP_CURSOR --> 	102 NIKHIL 4000		
			
		2ND TIME LOOP : 
				102 NIKHIL 4000
				
						102 NIKHIL 4000	
		EMP_CURSOR --> 	NO VALUE
			
		3RD TIME. - 	

			FETCH := EMP_CURSOR --> 	NO VALUE
			
			NOT FOUND
			
			
		FETCH EMP_CURSOR INTO EMPID,EMPSAL;
PROGRAM POINTER --> 

		IF V_FINISH = 1 THEN
		LEAVE L_LEVEL; 
		END IF;
			
		SELECT CONCAT('OLD SALARY OF EMPLOYEE : ', EMPID, 'AFTER INCREMENT SALARY BECOME ' , EMPSAL * 1.15);
		
		END LOOP L_LEVEL;
		
		CLOSE EMP_CURSOR;
		
		SELECT COUNT(*) FROM EMPLOYEES;
		
		END //
		
		DELIMITER ;

====================================================================

-- DUPLICATE ENTRY :-

	1062 FOR DUPLICATE ENTRY....
	
	DELIMITER //
	
	DROP PROCEDURE IF EXISTS P14 //
	
	CREATE PROCEDURE P14(X INT, Y VARCHAR(20))
	BEGIN
	
	DECLARE EXIT HANDLER FOR 1062
			
		
	INSERT INTO P14 VALUES(X,Y);
	
	END //
	
	DELIMITER ;
	





==========================================================

	DELIMITER //
	
	DROP PROCEDURE IF EXISTS P14 //
	
	CREATE PROCEDURE P14(X INT, Y VARCHAR(20))
	BEGIN
	
	DECLARE EXIT HANDLER FOR SQLEXCEPTION
			BEGIN
				INSERT INTO DAC_LOGS(EVENT,DESCRIPTION,ADDEDBY) 
						VALUES('GENERIC EXEPTION','EXCEPTION IN THE PROGRAM',USER());
				SELECT * FROM DAC_LOGS ORDER BY ID DESC LIMIT 1;
			END;
		
	INSERT INTO P14 VALUES(X,Y);
	
	END //
	
	DELIMITER ;
	
----------------------------------------------------------------------
----------------------------------------------------------------------

PLSQL : PROGRAM ALWASY EXECUTED AT SERVER END...

		NEVER RECOMMEND TO USE 
			DDL STATEMENTS INSIDE THE PROCEDURE/FUNCTIONS/TRIGGERS
	
MYSQL ALLOWS :-

	--- OLD SALARY AND NEW SALARY .....
	
EXAMPLE OF OLD AND NEW SALARY WITH TEMPORARY TABLES 
		WITH PROCEDURES.....
		
		
		DELIMITER //
		
		DROP PROCEDURE IF EXISTS P16;
		
		CREATE PROCEDURE P16()
		BEGIN
		
		DECLARE V_FINISH INT DEFAULT 0;
		DECLARE EMP_ID INT;
		DECLARE EMP_SAL INT;
		
		DECLARE EMP_CUR CURSOR 
				FOR SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES;
		DECLARE CONTINUE HANDLER FOR NOT FOUND
				SET V_FINISH = 1;
		
		-- TEMPORARY TABLE
		
		CREATE TEMPORARY TABLE EMP_TEMP
		(
			EMPID INT,
			OLDSALARY INT,
			NEWSALARY BIGINT
		);
		
		-- CURSOR OPEN
		
		OPEN EMP_CUR;
		
		-- LOOP START
		
		L_LEVEL : LOOP
		
			-- FETCH RECORDS
			
			FETCH EMP_CUR INTO EMP_ID,EMP_SAL;
			
			IF V_FINISH = 1 THEN
				LEAVE L_LEVEL;
			END IF;
		INSERT INTO EMP_TEMP VALUES(EMP_ID,EMP_SAL,EMP_SAL*1.15);
		
		-- END OF THE LOOP
		
		END LOOP L_LEVEL;
		
		CLOSE EMP_CUR;
		
		SELECT * FROM EMP_TEMP;
		
		DROP TABLE EMP_TEMP;
		
		END //
		
		DELIMITER ;
		
======================================================================

2 MINUTE....

PROCEDURES :- 

		WORKS WITH 
			VARIABLES
			CONDITIONALS (IF,CASE)
			CURSORS
			EXCEPTION HANDLER
			LOOPS
			
			TEMPORARY TABLE....
			
			DDL : NOT RECOMMENDED
						AS MOST OF THE DATABASES NOT ALLOWED TO DO THAT...
		
EXECUTION OF THE SET OF LINES....

			WHEN I NEED TO EXECUTE SET OF LINES AND WANT SOMETHING TO RETUN FROM THE BLOCK :- 
			
FUNCTIONS :- 

		EXECUTE THE SET OF LINES/ STATEMENTS AND RETUN DATATYPE....
		
		
		SYNTAX :- 
		
			CREATE FUNCTION FUNCATIONNAME()
						RETURNS DATATYPE
			BEGIN
				
				:: BODY OF THE FUNCTION ::
					
			END;
			
	EVERYTHING DONE IN THE PROCEDURE 
			CAN BE ACHIVED BY FUNCTIONS...
					NEED TO A RETUN VALUE FROM THE FUNCTION...
				
		CALL --------- FUNCTIONS CAN NOT BE EXECUTED WITH CALLED
		
		SELECT - COMMAND TO CATCH OR EXECUTEE THE FUNCTION....
		
****

		ADDING TWO NUMBER AND RETURNING THE SUM OF IT
		
		DELIMITER //
		
		CREATE FUNCTION SUMOFTWOVALUES(X INT,Y INT)
				RETURNS INT
		BEGIN
		
			RETURN X + Y;
		
		END //
		
		DELIMITER ;
		
		
		FUNCTIONS IN THE SYSTEM 
			WHEN EVER YOU WANT TO RETUN SOMETHING FROM THE BLOCK
			
	---------------------------------------------------------
							THANK YOU
	---------------------------------------------------------
		
		
			FUNCTION :-
					EXAMPLES 
			TRIGGERS :-
			
			SOME THEORY :-
			
				
		
		
		
		
		
			

		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	
	






			
			
		
		





			
				
				
				
				
				
				
				
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					